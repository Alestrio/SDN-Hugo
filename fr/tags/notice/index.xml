<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>notice on SDN-Cloudstack - Documentation</title><link>/fr/tags/notice/</link><description>Recent content in notice on SDN-Cloudstack - Documentation</description><generator>Hugo -- gohugo.io</generator><language>fr-fr</language><lastBuildDate>Tue, 21 Dec 2021 18:17:10 +0000</lastBuildDate><atom:link href="/fr/tags/notice/index.xml" rel="self" type="application/rss+xml"/><item><title>Google Artifact Registry</title><link>/fr/technique/deployment/google-ar/</link><pubDate>Tue, 21 Dec 2021 18:17:10 +0000</pubDate><guid>/fr/technique/deployment/google-ar/</guid><description>Originellement, l&amp;rsquo;hébergement de l&amp;rsquo;image Docker se faisait sur DockerHub, qui propose l&amp;rsquo;hébergement d&amp;rsquo;UNE image Docker privée. Notre projet en nécessite au minimum deux, ainsi, il a fallu trouver d&amp;rsquo;autres solutions.
Google Cloud Platform Et c&amp;rsquo;est dans nos recherches que nous avons découvert Google Cloud Platform, aussi appelé &amp;ldquo;GCP&amp;rdquo;. Cet ensemble d&amp;rsquo;outils cloud signé Google propose un service d&amp;rsquo;hébergement de conteneurs Docker appelé Google Artifact Registry, et propose une offre d&amp;rsquo;essai comprenant 300$ pendant 90j.</description></item><item><title>CI/CD : Continuous Integration / Continuous Developpement</title><link>/fr/technique/deployment/cicd/</link><pubDate>Sun, 17 Oct 2021 12:42:10 +0000</pubDate><guid>/fr/technique/deployment/cicd/</guid><description>Cet article traite de la CI/CD que nous appliquons pour notre projet.
Documentation Nous utilisons Github afin de stocker les sources de la documentation (ce site web). Ainsi, pour déployer les nouvelles versions, nous avons décidé d&amp;rsquo;utiliser une CI/CD. CI/CD veut dire Continuous Integration / Continuous Developpement, et permet d&amp;rsquo;automatiser la partie tests et la partie déploiement d&amp;rsquo;un projet.
Avant toute chose, il faut configurer la machine d&amp;rsquo;hébergement. Puisque notre site est auto-hébergé, nous allons utiliser ce que l&amp;rsquo;on appelle un &amp;ldquo;self-hosted github runner&amp;rdquo;, dont la documentation est trouvable ici : https://docs.</description></item><item><title>Déploiement de l'API</title><link>/fr/technique/deployment/deployment/</link><pubDate>Sun, 17 Oct 2021 12:42:10 +0000</pubDate><guid>/fr/technique/deployment/deployment/</guid><description>Prérequis Nous avons vu dans la partie config que le déploiement de notre API sur DockerHub est automatisé grâce à une GithubRunner. Nous allons donc nous servir de l&amp;rsquo;image docker générée afin de déclarer de nouvelles instances de notre API.
Docker-Compose Voici un exemple de configuration d&amp;rsquo;instanciation de l&amp;rsquo;API sur Docker-Compose :
api_r1: image: alestrio/sdn-cloudstack # Nom de l&amp;#39;image de base ports: - &amp;#34;8064:8000&amp;#34; # Exposition de port (bientôt obsolète, voir partie proxy.</description></item><item><title>Lien SNMP/API</title><link>/fr/technique/api/link_snmp/</link><pubDate>Sun, 17 Oct 2021 12:42:10 +0000</pubDate><guid>/fr/technique/api/link_snmp/</guid><description>Pour communiquer avec les actifs, l&amp;rsquo;API utilise le protocole SNMP. Vous pourrez trouver plus d&amp;rsquo;information sur le protocole sur la page dédiée des recherches. Cet article traite de l&amp;rsquo;utilisation de ce protocole avec l&amp;rsquo;API.
Bibliothèques de base : Au départ, pour concevoir notre API, nous avons utilisé PySNMP. Il s&amp;rsquo;agit d&amp;rsquo;une bibliothèque de haut niveau entièrement faite avec Python permettant d&amp;rsquo;utiliser le protocole SNMP avec le langage Python.
Il est possible de faire n&amp;rsquo;importe quelle action SNMP avec cette bibliothèque, cependant, elle présente plusieurs inconvénients :</description></item><item><title>List des URL de L'API</title><link>/fr/technique/api/api_url_list/</link><pubDate>Sun, 17 Oct 2021 12:42:10 +0000</pubDate><guid>/fr/technique/api/api_url_list/</guid><description>Liste des foction requise pour l&amp;rsquo;API et les URL corespondante.
GET Section générale Action URL obtenir la configuration global actuelle /api/v1/running-config Section des Vlan Action URL obtenir la liste de tous les vlan /api/v1/vlan/all obtenir les info d&amp;rsquo;un vlan spécifique par id /api/v1/vlan/{vlan_id} obtenir les info d&amp;rsquo;un vlan spécifique par nom /api/v1/vlan/{vlan_name} obtenir les interfaces membre d&amp;rsquo;un vlan par id /api/v1/vlan/{vlan_id}/interface obtenir les interfaces membre d&amp;rsquo;un vlan par nom /api/v1/vlan/{vlan_name}/interface Section des Interface Action URL obtenir la liste de toutes les interfaces /api/v1/interface/all obtenir les interfaces voisine d&amp;rsquo;une interface /api/v1/interface/{interface_id}/neighbor obtenir les info d&amp;rsquo;une interface spécifique /api/v1/interface/{interface_id} obtenir les @IP de toutes les interfaces /api/v1/interface/all/ip obtenir l&amp;rsquo;@IP d&amp;rsquo;une interface spécifique /api/v1/interface/{interface_id}/ip obtenir le status de toutes les interfaces /api/v1/interface/all/status obtenir le status d&amp;rsquo;une interface spécifique /api/v1/interface/{interface_id}/status Section des Switchs Action obtenir les propriétées d&amp;rsquo;un switch /api/v1/switch/{switch_id} obtenir la liste des vlans d&amp;rsquo;un switch /api/v1/switch/{switch_id}/vlan SET Section générale Action URL définir une nouvelle configuration global /api/v1/running-config/{config_id} Vlan Section Action URL Interface Section Action URL définir un nouveau mode d&amp;rsquo;acces à toutes les interfaces /api/v1/interface/all/{mode} définir un nouveau mode d&amp;rsquo;acces à une interface spécifique /api/v1/interface/{interface_id}/{mode} définir un même vlan à toutes les interfaces /api/v1/interface/all/{vlan_id} définir un vlan à une interface spécifique /api/v1/interface/{interface_id}/{vlan_id}</description></item></channel></rss>